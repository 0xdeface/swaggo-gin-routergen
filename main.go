package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"strings"
)

func main() {
	args := os.Args[1:]
	var handlerOwner string
	if len(args) == 1 {
		handlerOwner = args[0]
	}
	targetFile := os.Getenv("GOFILE")
	tagetPackage := os.Getenv("GOPACKAGE")
	fileSet := token.NewFileSet()
	result := make([]string, 0)
	node, err := parser.ParseFile(fileSet, targetFile, nil, parser.ParseComments)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	for _, decl := range node.Decls {
		if v, ok := decl.(*ast.FuncDecl); ok {
			if v.Doc == nil {
				continue
			}
			for _, doc := range v.Doc.List {
				if strings.HasPrefix(doc.Text, "// @Router") || strings.HasPrefix(doc.Text, "//@Router") {
					result = append(result, GenLine(v.Name.Name, doc.Text, handlerOwner))
				}
			}
		}
	}

	result = append(result, Footer())
	result = append(Header(tagetPackage, handlerOwner), result...)
	r := strings.Join(result, "\n")
	err = os.WriteFile("routes_gen.go", []byte(r), 0765)
	if err != nil {
		fmt.Println(err)
	}
}
func Header(pkg string, owner string) []string {
	result := make([]string, 4)
	result[0] = "package " + pkg
	result[1] = "// Code generated by github.com/0xdeface/swaggo-gin-routergen generator. DO NOT EDIT."
	result[2] = `import "github.com/gin-gonic/gin"`
	if len(owner) > 0 {
		result[3] = fmt.Sprintf("func RegisterHandlers(rg *gin.RouterGroup, h %v) {", owner)
	} else {
		result[3] = "func RegisterHandlers(rg *gin.RouterGroup) {"
	}
	return result
}
func Footer() string {
	return "}"
}
func GenLine(fName string, route string, owner string) string {
	getHttpMethod, err := GetHttpMethod(route)
	if err != nil {
		fmt.Println(err)
		return err.Error()
	}
	parsedRoute, err := GetRoute(route)
	if err != nil {
		fmt.Println(err)
		return err.Error()
	}
	if len(owner) > 0 {
		fName = "h." + fName
	}
	return fmt.Sprintf(`rg.%v("%v", %v)`, getHttpMethod, parsedRoute, fName)
}

func GetHttpMethod(route string) (string, error) {
	r, err := regexp.Compile(".+?\\[(.+?)\\].*?")
	if err != nil {
		fmt.Println(err.Error())
	}
	result := r.FindStringSubmatch(route)
	if len(result) == 2 {
		return strings.ToUpper(result[1]), nil
	}
	return "", fmt.Errorf("%v parse method error", route)
}

func GetRoute(route string) (string, error) {
	r, err := regexp.Compile(`.*?@Router\s*(.+)\[.+?\].*?`)
	if err != nil {
		fmt.Println(err.Error())
	}
	result := r.FindStringSubmatch(route)
	if len(result) == 2 {
		rt := strings.TrimSpace(result[1])
		r, err := regexp.Compile(`.*?{(.+)}.*?`)
		if err != nil {
			return "", nil
		}
		rt = r.ReplaceAllString(rt, ":$1")
		return rt, err
	}
	return "", nil
}
