package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func main() {
	handlerParam := flag.String("owner", "", "handler owner")
	stripParam := flag.String("strip", "", "# of iterations")
	packageParam := flag.Bool("package", false, "")
	flag.Parse()
	handlerOwner := *handlerParam
	stripPrefix := *stripParam
	packageMode := *packageParam
	_ = packageMode
	targetFile := os.Getenv("GOFILE")
	targetPackage := os.Getenv("GOPACKAGE")
	fileSet := token.NewFileSet()
	result := make([]string, 0)
	files := make([]*ast.File, 0)
	astFile, err := parser.ParseFile(fileSet, targetFile, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	if packageMode {
		dir := filepath.Dir(targetFile)
		astPackageMap, _ := parser.ParseDir(fileSet, dir, nil, parser.ParseComments)
		for _, v := range astPackageMap {
			for _, f := range v.Files {
				files = append(files, f)
			}
		}
	} else {
		files = append(files, astFile)
	}
	for _, file := range files {
		fileContent := parseFile(file, handlerOwner, stripPrefix)
		result = append(result, fileContent...)
	}

	result = append(result, Footer())
	result = append(Header(targetPackage, handlerOwner), result...)
	r := strings.Join(result, "\n")
	err = os.WriteFile("routes_gen.go", []byte(r), 0765)
	if err != nil {
		fmt.Println(err)
	}
}
func parseFile(f *ast.File, handlerOwner, stripPrefix string) (result []string) {
	for _, decl := range f.Decls {
		if v, ok := decl.(*ast.FuncDecl); ok {
			if v.Doc == nil {
				continue
			}
			for _, doc := range v.Doc.List {
				if strings.HasPrefix(doc.Text, "// @Router") || strings.HasPrefix(doc.Text, "//@Router") {
					result = append(result, GenLine(v.Name.Name, doc.Text, handlerOwner, stripPrefix))
				}
			}
		}
	}
	return
}

func Header(pkg string, owner string) []string {
	result := make([]string, 4)
	result[0] = "package " + pkg
	result[1] = "// Code generated by github.com/0xdeface/swaggo-gin-routergen generator. DO NOT EDIT."
	result[2] = `import "github.com/gin-gonic/gin"`
	if len(owner) > 0 {
		result[3] = fmt.Sprintf("func RegisterHandlers(rg *gin.RouterGroup, h %v) {", owner)
	} else {
		result[3] = "func RegisterHandlers(rg *gin.RouterGroup) {"
	}
	return result
}
func Footer() string {
	return "}"
}
func GenLine(fName string, route string, owner string, stripPrefix string) string {
	getHttpMethod, err := GetHttpMethod(route)
	if err != nil {
		fmt.Println(err)
		return err.Error()
	}
	parsedRoute, err := GetRoute(route, stripPrefix)
	if err != nil {
		fmt.Println(err)
		return err.Error()
	}
	if len(owner) > 0 {
		fName = "h." + fName
	}
	return fmt.Sprintf(`rg.%v("%v", %v)`, getHttpMethod, parsedRoute, fName)
}

func GetHttpMethod(route string) (string, error) {
	r, err := regexp.Compile(".+?\\[(.+?)\\].*?")
	if err != nil {
		fmt.Println(err.Error())
	}
	result := r.FindStringSubmatch(route)
	if len(result) == 2 {
		return strings.ToUpper(result[1]), nil
	}
	return "", fmt.Errorf("%v parse method error", route)
}

func GetRoute(route, strip string) (string, error) {
	r, err := regexp.Compile(`.*?@Router\s*(.+)\[.+?\].*?`)
	if err != nil {
		fmt.Println(err.Error())
	}
	result := r.FindStringSubmatch(route)
	if len(result) == 2 {
		rt := strings.TrimSpace(result[1])
		r, err := regexp.Compile(`{(.+)}`)
		if err != nil {
			return "", nil
		}
		rt = r.ReplaceAllString(rt, ":$1")
		if len(strip) > 0 {
			rt = strings.TrimPrefix(rt, strip)
			if !strings.HasPrefix(rt, "/") {
				rt = "/" + rt
			}
		}
		return rt, err
	}
	return "", nil
}
